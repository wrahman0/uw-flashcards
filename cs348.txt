* What is physical design?

Process of selecting data structures to implement conceptual schema.

* What is tuning?

Periodic adjustment of system's physical and/or conceptual schema to adjust for
changing performance characteristics and/or requirements.

* What is a workload in terms of database?

When the database is designed, its assigned an expected workload, which is the
expected amount of work that is to be performed by the database for a given
period of time.

* What is contained in a workload description?

- most important queries and their freq
- most important updates and their freq
- desired performance goal for each query/update

* What do we look at for query tuning?

- What relations are accessed?
- What attributes are accessed?
- What attributes occur in selection/join conditions?

* What do we look at for update queries?

- What is the type of update?
- What relations are affected?
- What attributes are affected?
- What attributes occur in selection/join conditions?

* What are physical storage options for each relations?

- Unsorted heap (file)
- Sorted file
- Hash file

* What are indexes used for?

Speed up lookups

* What are possible indexes?

- B-trees
- R-trees
- Hash tables

* What are the effects of adding LastnameIndex:

create index LastnameIndex
on Employee(Lastname) [CLUSTER];

drop index LastnameIndex;

- When selections involve the LastnameIndex, performance is improved
- Increase insert time for insertions
- Increase or decrease exec for Employee updates
- Increase space requirements for Employee

* Whats a clustering vs non-clustering index?

- For clustering index, rows are stored physically on the disk in the same order
as the index. One clustering index allowed.

- For non clustering index, there is a second list that has pointers to the
	physical rows. The physical rows are not modified. Can have multiple
	non clustering index
	
* What is co-clustering?

Their tuples are interleaved within the same file

* Why is co-clustering useful?

When storing heirarchical data (1:N relations).

* How does co-clustering affect performance?

- Speed up joins, especially foreign key joins => since in the same file
- Sequential scans of either relations become slower => since more data per file

* What are range queries?

select *
from R
where A >= C;

* What is the SQL for making one index from many attributes?

create index NameIndex
on Employee(Lastname, Firstname);

* Why does ordering matter in:
create index NameIndex
on Employee(Lastname, Firstname);

The tuples are organized by first Lastname then Firstname.

* What are the 5 physical design guidelines?

1. Dont index unless perf increase outweighs update overhead
2. Attr. in WHERE clauses are candidate index search keys
3. Multi-attr index used when several where conditions
4. Choose indexes that benefit the most number of queries
5. Each relation can have at most one clustering scheme

* What are 3 ways to tune the conceptual schema?

1. Re-normalization
2. Denormalization
3. Partitioning

* What is denormalization?

Purposefully introducing redundancy.

* What is normalization?

Removing redundant data.

* What is horizontal partitioning?

All the columns and subset of rows

* What is vertical partitioning?

Subset of the columns and all the row.

* What are the 4 tuning guidelines?

1. Avoid useless sorts ie GROUP BY
2. When possible, replace subqueries with joins
3. When possible, replace corelated subqueries with uncorrelated subqueries
4. Use vendor supplied tools

* What are the 2 tuning application guidelines?

1. Minimize comm cost
	i. return fewest possible cols and rows
	ii. update multiple rows with WHERE instead of cursor
2. Minimize lock contention and hot-spots
	i. delay updates as long as possible

* Why do we need transactions?

Transaction help with managing concurrent accesses to the db since the db is a
shared resource.

* What are problems caused by concurrency?

- Inconsistent reads (Staleness)
- Lost updates
- Non-repeatable reads

* What are problems caused by failures?

- if fails during query: partial query executed
- if fails after query: partial data updated
- if fails in between queries: info lost, ie withdraw money but didnt deposit

* What are transaction commands?

- Commit (sql: commit)
- Abort  (sql: rollback)

* What are properties of transactions?

- Atomic: 			entirely or not at all
- Consistent: 	preserves consistency of db
- Isolated:			dont interfere with each other
- Durable:			permanent after commit

* What are the 3 transaction modes options in sql?

1. diagnotic size: How many error conditions to record
2. access mode: READ ONLY or READ WRITE (default)
3. isolation level: how the interactions of transactions are managed

* What are the 4 isolation levels:

1. Level 0: Read uncommitted - can see uncommitted changes of others
2. Level 1: Read committed   - can see only committed changes but non repeatable
3. Level 2: Repeatable read  - repeatable reads but phantoms exists
4. Level 3: Serializability  - executed one at a time in same order

* What are the criteria for conflict?

1. 2 different transactions
2. operate on the same resource
3. one of the operation is a write

* How do you test for serializability?

Serialization iff serialization graph is acyclic.

* Know how to draw serialization graph

ch 11, slide 32

* What are relational design principals?

- semantic unity
- avoid info repetition
- avoid null
- avoid spurious joins

* What are problems with one large table?

- update problems
- insert problem
- delete problem
- increases space requirements

* What is functional dependency?

When a set of attributes uniquely determines another set of values

X -> Y means X functionally determines Y.

* What is a superkey?

Set of attr. such that no two tuples agree on their values for those attr.

* What is a candidate key?

Minimal superkey.

* What is a primary key?

A candidate key chosen by DBA.

* What is a closure?

Closure of a set of FD F (denoted F+) is the set of all FD that are satisfied by
every relational instance that satisfies F.

* How do you compute closures?

Algo: Ch 10, slide 18

* What is a schema decomp?

R = R_1 || ... || R_n

* What 3 things does a good composition avoid?

- losing info
- complicate checking of constraints
- contains anomalies 

* What is lossless-join decomp?

If rejoining the decomposed tables always produces exactly the tuples in the
original.

The decomp of R = {R1, R2} is lossless iff the common attr of R1 and R2 form a
superkey of either schema.

* What is a normal form?

When you transform the schema into a form where there is a primary key and a set
of mutually indep attributes.

* What are the normal forms dependant on FDs?

- BCNF
- 3NF

* How do you determine if a schema is BCNF?

If X -> Y then X is a superkey of the relation. 

Example: R = {Sno, Sname, City, Pno, Pname, Price}

Sno -> Sname, City
Pno -> Pname
Sno, Pno -> Price

Sno determines Sname and city but is not a superkey because Sno and Pno are
needed to determine price.

* What is 3NF?

In BCNF, we have that for any FD, X is a superkey. For 3NF we have that if Y is
not prime, ie its not part of any candidate key, then X should be a superkey.

* What is the minimal cover?

For every set of FD F, there is a minimal set of dependencies F' (Min cover)

* What do functional dependencies do?

Provides clues towards eliminating redundancies in relational schema.

Goals:

Decompose such that:
1. lossless-join
2. dependency preserving
3. BCNF (at least 3NF)
